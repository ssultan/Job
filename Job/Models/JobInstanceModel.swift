//
//  selJobInstance.swift
//  Job
//
//  Created by Saleh Sultan on 5/21/19.
//  Copyright Â© 2019 Davaco Inc. All rights reserved.
//

import UIKit
//import Appsee

class JobInstanceModel: NSObject {

    
    //This is the ID generated by Server. It's auto incremented long integer. we will get it from server after we successfuly send the instance to the server
    @objc dynamic var instServerId: String?
    
    //This Id is also known as 'clientId', which is generated by Client side(mobile)
    @objc dynamic var instId: String?
    
    @objc dynamic var errorCode: Int64 = 0                  // Store the error code we received last time send process.
    @objc dynamic var isCompleted: NSNumber = NSNumber(value: false)            // To make sure if the instance has been completed or not. Based on that we will deceide if we need to show that specific instance into 'Completed/Unsent Surveys' page.
    @objc dynamic var isCompleteNSend: NSNumber = NSNumber(value: false)        // This flag will make sure, if the system needs to consider this instance in 'Complete/Unsent surveys' page or not. Because we don't need to show instance which is marked for complete and send since user will not have access to a complete instance which is marked for send (If there was no error in the instance, after validating from server)
    @objc dynamic var isSent: NSNumber = NSNumber(value: false)                 // For Complete Instance, to make sure if the instance has been sent or not
    @objc dynamic var isSentForProcessing: NSNumber = NSNumber(value: false)    // It will track if background thread need to check this survey instance
    @objc dynamic var isSentOrUpdated:NSNumber = NSNumber(value: false)         // This flag will track if we need to display this instance in "Transmit Report" page
    @objc dynamic var photoAckReceived: NSNumber = NSNumber (value: false)      // This flag will make sure that server received instance and all the photos
    @objc dynamic var startDate: NSDate?
    @objc dynamic var completedDate: NSDate?
    @objc dynamic var succPhotoUploadTime: NSDate?
    
    // This time object is responsible to track the instance start sending time for transmit report page.
    @objc dynamic var instanceSentTime: NSDate?
    
    @objc dynamic var projectNumber: String?
    @objc dynamic var status: String?
    @objc dynamic var templateId: String?   // This is requried for sync the existing instance with the template
    @objc dynamic var templateName: String? // When assignemed a template, if there is an incompleted instance; then this will help us to find ou the instance.
    @objc dynamic var locationId: String?
    @objc dynamic var storeNumber: String?
    @objc dynamic var location: LocationModel!
    @objc dynamic var template: TemplateModel!
    @objc dynamic var project: ProjectModel!
    @objc dynamic var user: UserModel!
    dynamic var documents = [DocumentModel]()
    dynamic var orphaneAnsModels = [AnswerModel]()
    @objc dynamic var jobVisits = NSMutableArray()
    @objc dynamic var dbRawInstanceObj: AnyObject?
    
    
    // This 'Flagged' and 'Comments' veriables always contain null. This is something we thought to implement in Survey V2, but never implemented. If user want to put specical comment for the survey instance, then he can put this flagged verialbe to 'True' to let the admin know that there is something special in this survey. And amdin need to check the associated commetns for this surve.
    @objc dynamic var flagged:NSNumber?
    @objc dynamic var comments = [CommentModel]()
    
    
    // When creating a new object template
    init(tempModel: TemplateModel) {
        super.init()
        self.template = tempModel
        self.project = tempModel.project
        self.templateId = tempModel.templateId
        self.templateName = tempModel.templateName
        self.projectNumber = tempModel.projectNumber
        self.jobVisits = self.loadTasks(taskList: tempModel.tasks)
        self.jobVisits.add(JobVisitModel())
    }
    
    init(jobInstance: JobInstance) {
        super.init()
        
        self.isCompleted = jobInstance.isCompleted ?? NSNumber (value: false)
        self.isCompleteNSend = jobInstance.isCompleteNSend ?? NSNumber (value: false)
        self.isSent = jobInstance.isSent ?? NSNumber (value: false)
        self.isSentForProcessing = jobInstance.isSentForProcessing ?? NSNumber (value: false)
        self.photoAckReceived = jobInstance.photoAckReceived ?? NSNumber (value: false)
        self.isSentOrUpdated = jobInstance.isSentOrUpdated ?? NSNumber(value: false)
        self.startDate = jobInstance.startDate
        self.completedDate = jobInstance.completedDate
        self.succPhotoUploadTime = jobInstance.succPhotoUploadTime
        self.instanceSentTime = jobInstance.instanceSentTime
        
        if self.instanceSentTime == nil && jobInstance.isSentOrUpdated != nil && Bool(truncating: jobInstance.isSentOrUpdated!) {
            if let compDate = self.completedDate {
                self.instanceSentTime = compDate
            } else if let succPhUpTime = self.succPhotoUploadTime {
                self.instanceSentTime = succPhUpTime
            }
        }
        
        self.instId = jobInstance.instId
        self.instServerId = jobInstance.instServerId
        if let jobTempMo = jobInstance.jobTemplate {
            self.projectNumber = jobTempMo.tempProject!.projectNumber
            self.template = TemplateModel(template: jobTempMo)
        }
        self.storeNumber = jobInstance.storeNumber
        self.locationId = jobInstance.locationId
        self.status = jobInstance.status
        self.errorCode = (jobInstance.error != nil) ? Int64(jobInstance.error!.errorCode) : 0
        self.templateId = jobInstance.templateId
        self.templateName = jobInstance.jobTemplate != nil ? jobInstance.jobTemplate!.templateName : (jobInstance.templateName ?? "Unknown")
        self.location = jobInstance.jobLocation != nil ? LocationModel(location: jobInstance.jobLocation!) : nil
        self.project = jobInstance.jobTemplate != nil ? ProjectModel(template: jobInstance.jobTemplate!) : nil
        self.user = UserModel(manifest: jobInstance.manifest!)
        
        if let documentList = jobInstance.documents {
            for document in documentList {
                if let docModel = document as? Document {
                    if !Bool(truncating: docModel.isPhotoDeleted ?? 0) {
                        self.documents.append(DocumentModel(document: docModel))
                    }
                }
            }
        }
        
        if let comments = jobInstance.comments {
            for commentObj in comments {
                if let comment = commentObj as? Comment {
                    if comment.answerComment == nil {
                        self.comments.append(CommentModel(comment: comment))
                    }
                }
            }
        }
        
        loadTemplateTasks()
        if self.jobVisits.count > 0 {
            connectAnswersWithFVs(jobInstance)
        }
        
        self.dbRawInstanceObj = jobInstance
    }
    
    fileprivate func loadTemplateTasks() {
        if let temp = self.template {
            self.jobVisits = self.loadTasks(taskList: temp.tasks)
            self.jobVisits.add(JobVisitModel()) // Save page
        }
    }
    
    fileprivate func connectAnswersWithFVs(_ jobInstance: JobInstance) {
        if let answers = jobInstance.answers?.sorted(by: { Int(($0 as? Answer)?.task?.ordinal ?? "0")! < Int(($1 as? Answer)?.task?.ordinal ?? "0")! }) {
            for ansObj in answers {
                if let answer = ansObj as? Answer {
                    let ansModel = AnswerModel(answer: answer)
                    let fvArray = self.jobVisits.filtered(using: NSPredicate(format: "task.taskId = %@",
                                                                               ansModel.task?.taskId ?? "0"))
                    
                    if fvArray.count > 0, let jobVisit = fvArray.first as? JobVisitModel {
                        jobVisit.answer = ansModel
                    }
                }
            }
        }
    }
    
    func checkJobAnswers(isCompletedJob:Bool, completionHandler:(_ numOfAnsRequired: Int, _ numOfPicRequired: Int, _ isInstanceCompleted: Bool) -> ()) {
        var isInstanceCompleted = true
        var numOfAnsRequired = 0
        var numOfPicRequired = 0
        
        for fvObj in self.jobVisits {
            if let fvModel = fvObj as? JobVisitModel {
                let isFvCompleted = isCompletedJob ? fvModel.checkFieldVisitIfCompleted(&numOfAnsRequired, &numOfPicRequired) : fvModel.checkSubTaskPhotoTaken(&numOfPicRequired)
                if isInstanceCompleted && isFvCompleted == false {
                    isInstanceCompleted = false
                }
            }
        }
        completionHandler(numOfAnsRequired, numOfPicRequired, isInstanceCompleted);
    }
    
    
    // This function is responsible to generate the field visit lisst of a survey. Field visit model will contain task and answer model. In future we will add more fields into an field visit instance.
    func loadTasks(taskList: [TaskModel]) -> NSMutableArray {
        
        let outputFBArr = NSMutableArray()
        
        // 'getAllTasks' function will take the list of all tasks. Resposibilites are -
        // - Ignore all the branchTo tasks if not answered.
        // - Ignore all the child tasks
        // - Ignore all the configurable tasks if not anwered. Load if answered.
        var tasks = TaskServices.getAllTasks(tasks: taskList)
        tasks = (tasks.sorted(by: { Int($0.ordinal ?? "0")! < Int($1.ordinal ?? "0")! }))
        
        
        for task in tasks {
            
            let jobVisit = JobVisitModel(taskModel: task)
            jobVisit.ordinal = task.ordinal
            jobVisit.taskNo = task.taskNo
            outputFBArr.add(jobVisit)
            
            if task.subTasks.count > 0 {
                // Recursive function to load all the child subtask of a task.
                let subTaskList = self.loadTasks(taskList: task.subTasks)
                for chilTk in subTaskList {
                    outputFBArr.add(chilTk)
                }
            }
        }
        return outputFBArr
    }
    
    
    // Recursive function to remove all childs of a configurable tasks
    func removeConfiChild(fvModel: JobVisitModel) {
        let configChilds = self.jobVisits.filtered(using: NSPredicate(format: "parentFVModel = %@", fvModel))
        
        // For child of a configurable quetion.
        for childFvModelObj in configChilds {
            if let childFvModel = childFvModelObj as? JobVisitModel {
                self.removeConfiChild(fvModel: childFvModel)
                
                self.orphaneAnsModels.append(childFvModel.answer)
                self.jobVisits.remove(childFvModel)
            }
        }
        
        // For subtasks like Address and measurements
        for subFvModels in fvModel.subFVModels {
            self.orphaneAnsModels.append(subFvModels.answer)
        }
        
        
        /* Before removing the field visit model from the shared instance, save the answer model into 'OrphaneAnsModels' object. Because we need to store the subtask answer object in our database according to the requirement even we decreased the answered configurable task set number. So that if user changed their mind and wanna increase the set number later, then they won't lose their previous entered data and system will automatically retrieve data from database. But coding purpose we are store the orphane answer models in our local instance object.
         */
        self.orphaneAnsModels.append(fvModel.answer)
        self.jobVisits.remove(fvModel)
    }
    
    /*
     If there is a answer model is already available for the same task Number and child task in 'OrphaneAnswerModels' array, then connect the answer to the approprite config sub task model. Otherwise, return an empty answer object for the Qusetion.
     */
    func getAnswerModelForTask(task: TaskModel, withAllAvailAnswers answers:[Answer]?) -> AnswerModel {
        
        if let taskId = task.taskId, let allAnswers = answers {
            if let subAnsObj = allAnswers.filter({ $0.task!.taskId ?? "-1" == taskId}).first
            {
                return AnswerModel(answer: subAnsObj)
            }
        }
        else if let orphaneAnswer = self.orphaneAnsModels.filter({ $0.task != nil && $0.task!.taskId == task.taskId }).first {
            // Before connecting the orphane Answer to a parent task children sub-task; remove the answer model item from the orphane Answer model. Since it is no longer a orphane answer.
            let index = self.orphaneAnsModels.firstIndex(of: orphaneAnswer)
            self.orphaneAnsModels.remove(at: index!)
            return orphaneAnswer
        }
        return AnswerModel(task: task)
    }
    
    
    // Remove a document from field visit images array OR instance document array.
    @objc func removeDocumentFromInst(documentId: String) {
        var idx = 0
        for document in self.documents {
            if document.documentId == documentId {
                self.documents.remove(at: idx)
                break
            }
            idx += 1
        }
    }
    
    fileprivate func countNoOfPhotosNeedToSend(_ jobVisit: JobVisitModel, isSent: Bool) -> Int {
        var totalPhotos = 0
        
        if let answer = jobVisit.answer {
            totalPhotos += answer.ansDocuments.count > 0 ? answer.ansDocuments.filter({ $0.isSent == NSNumber(value: isSent)  }).count : 0
            
            for subFVModel in jobVisit.subFVModels {
                totalPhotos += countNoOfPhotosNeedToSend(subFVModel, isSent: isSent)
            }
        }
        return totalPhotos
    }
    
    func getTotalPhotosOfTheInstances(isSent: Bool) -> Int {
        var totalPhotos = self.documents.filter({ $0.isSent == NSNumber(value: isSent) }).count
        
        for fvModel in self.jobVisits {
            if let jobVisit = fvModel as? JobVisitModel {
                totalPhotos += countNoOfPhotosNeedToSend(jobVisit, isSent: isSent)
            }
        }
        return totalPhotos
    }
    
    
    func getJSONForJobInstance() -> [String : AnyObject] {
        var params = [String: AnyObject]()
        
        //This is the ID generated by Server. It's auto incremented long integer.
        if let sId = self.instServerId {
            params[Constants.ApiRequestFields.Key_Id] = sId as AnyObject
        }
        
        // Also known as clientId, becuase this id is generated by client side mobile
        if let clientId = self.instId {
            params[Constants.ApiRequestFields.Key_ClientId] = clientId as AnyObject
        }
        
        if let templateId = self.templateId {
            params[Constants.ApiRequestFields.Key_TemplateId] = templateId as AnyObject
        }
        if let projectId = self.template.projectId {
            params[Constants.ApiRequestFields.Key_ProjectId] = projectId as AnyObject
        }
        if let locId = self.locationId {
            params[Constants.ApiRequestFields.Key_LocationId] = locId as AnyObject
        }
        if let startDate = self.startDate {
            params[Constants.ApiRequestFields.Key_StartedOn] = Utility.stringFromDate(date: startDate as Date, format: Constants.SERVER_EXPECT_DATE_FORMAT) as AnyObject
        }
        if let completedDate = self.completedDate {
            params[Constants.ApiRequestFields.Key_CompletedOn] = Utility.stringFromDate(date: completedDate as Date, format: Constants.SERVER_EXPECT_DATE_FORMAT) as AnyObject
        }
        params[Constants.ApiRequestFields.Key_DocumentCount] = "\(self.documents.count)" as AnyObject
        if let userName = self.user.userName {
            params[Constants.ApiRequestFields.Key_UserName] = userName as AnyObject
        }
        params[Constants.ApiRequestFields.Key_DeviceId] = AppInfo.sharedInstance.deviceId as AnyObject
        
        
        // This 'Flagged' and 'Comments' veriables always contain null. This is something we thought to implement in Survey V2, but never implemented. If user want to put specical comment for the survey instance, then he can put this flagged verialbe to 'True' to let the admin know that there is something special in this survey. And amdin need to check the associated commetns for this surve.
        if let flagged = self.flagged {
            params[Constants.ApiRequestFields.Key_Flagged] = flagged.boolValue as AnyObject
        }
        
        let commentList = NSMutableArray()
        for comment in self.comments {
            commentList.add(comment.makeJson())
        }
        params[Constants.ApiRequestFields.Key_CtPostsList] = commentList as AnyObject
        
        
        //Describe all the answers here
        let answersArray = NSMutableArray()
        for fvModel in self.jobVisits {
            if let jobVisit = fvModel as? JobVisitModel {
                if let answer = jobVisit.answer, let task = jobVisit.task {
                    if (task.isActive ?? 0).boolValue {
                        answersArray.add(answer.makeJsonForAnswer())
                    }
                    else {
                        print ("Inactive Task ServerId: \(answer.ansServerId ?? ""), ClientId: \(answer.ansId ?? "")" )
                        
                    }
                }
                
                for subFVModel in jobVisit.subFVModels {
                    if let answer = subFVModel.answer, let task = jobVisit.task {
                        if (task.isActive ?? 0).boolValue  {
                            answersArray.add(answer.makeJsonForAnswer())
                        } else {
                            print ("Inactive Sub-Task ServerId: \(answer.ansServerId ?? ""), ClientId: \(answer.ansId ?? "")" )
                        }
                    }
                    
                    //IMPORTANT: For Job app, there are not 3rd level of sub-task
                    // 3rd level. since we support up to 3rd level.
                    for chilfOfSubFV in subFVModel.subFVModels {
                        if let answer = chilfOfSubFV.answer, let task = jobVisit.task {
                            if (task.isActive ?? 0).boolValue  {
                                answersArray.add(answer.makeJsonForAnswer())
                            } else {
                                print ("Inactive sub-sub-Task ServerId: \(answer.ansServerId ?? ""), ClientId: \(answer.ansId ?? "")" )
                            }
                        }
                    }
                }
            }
        }
        
        params[Constants.ApiRequestFields.Key_Answers] = answersArray as AnyObject
        return params
    }
    
    func finalizeInstance(forDocIdList docIdList: [String], andServerDocIds serverIds:[String]) {
        var isMissingPhotos = false
        let docMoList = DBDocumentServices.getAllDocuments(forInstance: self)
        
        
        //For tracking if there is any photo with null object
        var ansIdsDocMiss:[String] = [String]()
        var fvDocIdsMiss:[String] = [String]()
        
        for docModel in docMoList {
            if let docId = docModel.documentId {
                
                if Bool(truncating: docModel.isDataNull ?? false) == false && !docIdList.contains(docId.uppercased()) &&
                    !DBErrorLogServices.isDocumentExistInErrorTable(documentMo: docModel) {
                    
                    isMissingPhotos = true
                    docModel.isSent = NSNumber(value: false)
                    DBDocumentServices.updateDocument(documentModel: docModel)
                    
                    //Appsee.addEvent("Photo Ack. missing photo details", withProperties: ["Username": AppInfo.sharedInstance.username ?? "", "InstanceId":self.instServerId ?? "", "DocumentClientId": docModel.documentId ?? ""])
                }
                else if Bool(truncating: docModel.isDataNull ?? false) || DBErrorLogServices.isDocumentExistInErrorTable(documentMo: docModel) {
                    if let taskNo = docModel.associatedQNo {
                        ansIdsDocMiss.append(taskNo)
                    }
                    else {
                        fvDocIdsMiss.append(docId)
                    }
                }
                else if docIdList.contains(docId.uppercased()) {
                    if let idx = docIdList.firstIndex(of: docId) {
                        docModel.docServerId = serverIds[idx]
                        DBDocumentServices.updateDocument(documentModel: docModel)
                    }
                }
            }
        }
        
        if !isMissingPhotos {
            self.photoAckReceived = NSNumber(value: true)
            if ansIdsDocMiss.count == 0 && fvDocIdsMiss.count == 0 {
                self.status = StringConstants.StatusMessages.SuccessfullySent
            } else {
                self.status = self.getStatusMsg(forAnsNo: ansIdsDocMiss, andForFvDocs: fvDocIdsMiss)
            }
            DBJobInstanceServices.updateJobInstance(jobInstance: self)
            
            if let status = self.status, let clientId = self.instId, let instServerId = self.instServerId {
                NotificationCenter.default.post(name: NSNotification.Name(rawValue: Constants.NotificationsName.ReloadReportTableNotifier),
                                                object: nil, userInfo: [Constants.BgUIUpdateNotifierKeys.KeyInstanceId: clientId,
                                                                        Constants.BgUIUpdateNotifierKeys.KeyStatus : status,
                                                                        Constants.BgUIUpdateNotifierKeys.KeyInstServerId: instServerId])
            }
        }
    }
    
    fileprivate func getStatusMsg(forAnsNo ansNoDocMissing:[String], andForFvDocs fvDocList:[String]) -> String {
        var msgBody = ""
        if ansNoDocMissing.count > 0 && fvDocList.count > 0 {
            msgBody = "photos for Q#(\(ansNoDocMissing.unique().joined(separator: ","))) and FV photos"
        } else if ansNoDocMissing.count > 0 {
            msgBody = "photos for Q#(\(ansNoDocMissing.unique().joined(separator: ",")))"
        } else {
            msgBody = "FV photos"
        }
        
        return "Successfully Sent. Failed to send \(msgBody). Please contact Mobile Support."
    }
    
    func updateInstAfterPhotoUploadProcessCompleted(forNumOfFailed failedToSend: Int, andUpdating isUpdating: Bool) {
        // NEW: Get Total number of photos from the singleton object. Since we are not storing 'isBranchToQues' field in database, therefore pull the counter value from database was giving wrong value.
        let totalDocNeedToSend:Int = self.getTotalPhotosOfTheInstances(isSent: false)
        
        
        // If 'failedToSend' count return 0, but 'totalDocNeedToSend' count return more than 0. That means there is issue with configurable child answers. There must be an orphan answer object which doesn't associated with user's servey, but user took photo for them. System suppose to delete all the orphane images as soon as user hit the 'Complete & Send' Button. But for update request, it's different. So still we are considering this in here.
        // If user mark the survey as Completed, then these 2 count will contain always the same value. Because we handled it in 'Fieldvisit' page. Now, if is a incompleted survey, then there is a chance of having orphan answer and photos. And we can not delete them until user mark the survey as Completed.
        // So if the request is update request and 'failedToSend' flag return 0, then mark the instance is 'Successfully Updated'. No need to check 'totalDocNeedToSend'
        if failedToSend == 0 || (isUpdating && failedToSend == 0){
            self.errorCode = 0
            self.succPhotoUploadTime = NSDate()
            self.status = (isUpdating ? StringConstants.StatusMessages.SuccessfullyUpdated : StringConstants.StatusMessages.SuccessfullySent)
        } else {
            let totalDocSent = DBDocumentServices.getAllDocuments(forInstance: self).count
            if totalDocNeedToSend != failedToSend && totalDocNeedToSend != totalDocSent {
                //Appsee.addEvent("Failed To Send counter is wrong", withProperties: ["Username" : AppInfo.sharedInstance.username ?? "", "totalDocNeedToSend": totalDocNeedToSend, "failedToSend": failedToSend, "totalDocSent": totalDocSent])
            }
            self.status = "\(totalDocSent)/\(failedToSend + totalDocSent) photos sent. Attempting to resend \(failedToSend) photos. Please do not log off."
        }
        
        // **************** update instance *****************
        DBJobInstanceServices.updateJobInstance(jobInstance: self)
        
        if let status = self.status, let clientId = self.instId, let instServerId = self.instServerId {
            NotificationCenter.default.post(name: NSNotification.Name(rawValue: Constants.NotificationsName.ReloadReportTableNotifier),
                                            object: nil, userInfo: [Constants.BgUIUpdateNotifierKeys.KeyInstanceId: clientId,
                                                                    Constants.BgUIUpdateNotifierKeys.KeyStatus : status,
                                                                    Constants.BgUIUpdateNotifierKeys.KeyInstanceSentTime : self.succPhotoUploadTime == nil ? NSDate() : self.succPhotoUploadTime!,
                                                                    Constants.BgUIUpdateNotifierKeys.KeyInstServerId: instServerId])
        }
    }
}
